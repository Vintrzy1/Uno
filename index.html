<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>UNO CARD GAMES</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a2b3c;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none; 
        }
        canvas {
            display: block;
            -webkit-tap-highlight-color: transparent;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * KAMUS BAHASA
 */
const LANG = {
    ID: {
        play_2: "2 PEMAIN",
        play_4: "4 PEMAIN",
        online: "MODE ONLINE",
        quit: "KELUAR",
        draw: "AMBIL",
        deck: "DECK",
        turn_you: "Giliran Anda!",
        turn_bot: "Giliran ",
        win_you: "ANDA MENANG!",
        win_bot_prefix: "", 
        win_bot_suffix: " MENANG!",
        color_pick: "PILIH WARNA",
        coming_soon: "SEGERA HADIR!",
        coming_soon_desc: "Mode Online sedang dikembangkan",
        profile_hint: "(Klik untuk ubah)",
        quit_title: "Keluar Permainan?",
        quit_msg: "Kamu yakin? Nanti kamu akan kalah loh.",
        profile_title: "Ubah Nama Profil",
        btn_yes: "YA",
        btn_no: "TIDAK",
        btn_save: "SIMPAN",
        btn_cancel: "BATAL",
        bot_pick: "memilih",
        bot_draw: "mengambil kartu",
        skip: "SKIP!",
        reverse: "ARAH BERBALIK!",
        reverse_skip: "REVERSE (SKIP)!",
        plus2: "+2 untuk",
        plus4: "+4 untuk",
        no_move: "Tidak ada kartu cocok! Ambil kartu."
    },
    EN: {
        play_2: "2 PLAYERS",
        play_4: "4 PLAYERS",
        online: "ONLINE MODE",
        quit: "EXIT",
        draw: "DRAW",
        deck: "DECK",
        turn_you: "Your Turn!",
        turn_bot: "'s Turn",
        win_you: "YOU WON!",
        win_bot_prefix: "",
        win_bot_suffix: " WON!",
        color_pick: "CHOOSE COLOR",
        coming_soon: "COMING SOON!",
        coming_soon_desc: "Online Mode is under development",
        profile_hint: "(Click to edit)",
        quit_title: "Quit Game?",
        quit_msg: "Are you sure? You will lose the game.",
        profile_title: "Change Profile Name",
        btn_yes: "YES",
        btn_no: "NO",
        btn_save: "SAVE",
        btn_cancel: "CANCEL",
        bot_pick: "chose",
        bot_draw: "drew a card",
        skip: "SKIP!",
        reverse: "REVERSE!",
        reverse_skip: "REVERSE (SKIP)!",
        plus2: "+2 for",
        plus4: "+4 for",
        no_move: "No valid cards! Draw a card."
    }
};

/**
 * KONFIGURASI DAN VARIABEL GLOBAL
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let SCREEN_W = window.innerWidth;
let SCREEN_H = window.innerHeight;

const COLORS = {
    red: '#ff5555',
    blue: '#5555ff',
    green: '#55aa55',
    yellow: '#ffaa00',
    black: '#222', 
    white: '#ffffff',
    grey: '#555',
    gold: '#ffd700',
    dark_bg: '#1e3c72',
    btn_shadow: 'rgba(0,0,0,0.3)'
};

// UKURAN DASAR (Desktop)
const BASE_CARD_W = 80;
const BASE_CARD_H = 115;
const BASE_CARD_RADIUS = 8;

// VARIABEL DINAMIS
let UI_SCALE = 1; 
let CARD_W = BASE_CARD_W;
let CARD_H = BASE_CARD_H;
let CARD_RADIUS = BASE_CARD_RADIUS;

const STATE = {
    MENU: 0,
    PLAYING: 1,
    COLOR_PICKER: 2,
    GAME_OVER: 3,
    ANIMATING: 4 
};

let currentState = STATE.MENU;
let winner = null;
const mouse = { x: 0, y: 0, down: false, clicked: false };

// --- VARIABEL IKLAN ---
let interstitialAd = null;
let isAdLoading = false;

// --- LOGIKA IKLAN APK (ADMOB) ---
async function onDeviceReady() {
    console.log("Device Ready. Memulai AdMob...");
    if (navigator.connection && navigator.connection.type === 'none') {
        console.log("Offline: Iklan tidak ditampilkan.");
    }
    if (typeof admob !== 'undefined') {
        try {
            await admob.start();
            const banner = new admob.BannerAd({
                adUnitId: 'ca-app-pub-4389289343937853/8974663429', 
                position: 'bottom'
            });
            banner.show().catch(e => console.error("Banner error:", e));
            loadInterstitial();
        } catch (e) { console.error("AdMob Init Error:", e); }
    }
}

async function loadInterstitial() {
    if (typeof admob === 'undefined' || interstitialAd || isAdLoading) return;
    isAdLoading = true;
    try {
        const ad = new admob.InterstitialAd({
            adUnitId: 'ca-app-pub-4389289343937853/9633031171' 
        });
        await ad.load();
        interstitialAd = ad;
        isAdLoading = false;
    } catch (e) {
        isAdLoading = false;
        setTimeout(loadInterstitial, 10000);
    }
}

async function showInterstitialAd() {
    if (interstitialAd) {
        try {
            await interstitialAd.show();
            interstitialAd = null;
            setTimeout(loadInterstitial, 2000); 
        } catch (e) {
            interstitialAd = null;
            loadInterstitial();
        }
    } else {
        loadInterstitial();
    }
}

if (document.URL.indexOf( 'http://' ) === -1 && document.URL.indexOf( 'https://' ) === -1) {
    document.addEventListener('deviceready', onDeviceReady, false);
}

/**
 * KELAS ANIMASI KARTU
 */
class CardAnimation {
    constructor(card, startX, startY, endX, endY, startRot, endRot, callback) {
        this.card = card;
        this.startX = startX;
        this.startY = startY;
        this.endX = endX;
        this.endY = endY;
        this.startRot = startRot;
        this.endRot = endRot;
        
        this.currentX = startX;
        this.currentY = startY;
        this.currentRot = startRot;
        
        this.progress = 0;
        this.speed = 0.08;
        this.callback = callback;
        this.finished = false;
    }

    update() {
        if (this.finished) return;

        this.progress += this.speed;
        if (this.progress >= 1) {
            this.progress = 1;
            this.finished = true;
            if (this.callback) this.callback();
        }

        let t = this.progress * this.progress * (3 - 2 * this.progress);

        this.currentX = this.startX + (this.endX - this.startX) * t;
        this.currentY = this.startY + (this.endY - this.startY) * t;
        
        let diffRot = this.endRot - this.startRot;
        while (diffRot > Math.PI) diffRot -= Math.PI * 2;
        while (diffRot < -Math.PI) diffRot += Math.PI * 2;

        this.currentRot = this.startRot + diffRot * t;
    }

    draw() {
        let oldX = this.card.x;
        let oldY = this.card.y;
        
        this.card.x = this.currentX;
        this.card.y = this.currentY;
        
        let flyingScale = 1.1; 
        
        ctx.save();
        ctx.translate(this.currentX, this.currentY);
        ctx.rotate(this.currentRot);
        ctx.scale(flyingScale, flyingScale);
        
        ctx.shadowColor = "rgba(0,0,0,0.3)";
        ctx.shadowBlur = 15 * UI_SCALE;
        ctx.shadowOffsetY = 10 * UI_SCALE;
        
        // Base
        ctx.fillStyle = COLORS.white;
        ctx.beginPath(); ctx.roundRect(-CARD_W/2, -CARD_H/2, CARD_W, CARD_H, CARD_RADIUS); ctx.fill();
        ctx.shadowColor = "transparent";

        let mainColor = (this.card.color === 'black') ? COLORS.black : COLORS[this.card.color];
        ctx.fillStyle = mainColor;
        ctx.beginPath(); ctx.roundRect(-CARD_W/2 + (5*UI_SCALE), -CARD_H/2 + (5*UI_SCALE), CARD_W - (10*UI_SCALE), CARD_H - (10*UI_SCALE), CARD_RADIUS); ctx.fill();

        if (this.card.type === 'wild' || this.card.type === 'wild4') {
             this.card.drawWildFace();
        } else {
             this.card.drawNormalFace(mainColor);
        }
        ctx.restore();

        this.card.x = oldX;
        this.card.y = oldY;
    }
}

/**
 * KELAS CARD (KARTU)
 */
class Card {
    constructor(color, value, type) {
        this.color = color;
        this.value = value;
        this.type = type;
        this.x = SCREEN_W / 2; 
        this.y = SCREEN_H + 200;
        this.isHovered = false;
    }

    draw(x, y, faceUp = true, scale = 1, dimmed = false, rotation = 0) {
        // Logic Interpolasi
        if (rotation === 0 && faceUp) { 
             this.x += (x - this.x) * 0.2;
             this.y += (y - this.y) * 0.2;
        } else {
             this.x = x; this.y = y;
        }

        let drawScale = scale;
        let hoverLift = (UI_SCALE < 0.8) ? 15 : 30;

        let renderX = (rotation === 0 && faceUp) ? this.x : x;
        let renderY = (rotation === 0 && faceUp) ? this.y : y;

        if (this.isHovered && faceUp && !dimmed && rotation === 0) {
            renderY -= hoverLift;
            drawScale = 1.1;
        }

        ctx.save();
        ctx.translate(renderX, renderY); 
        ctx.rotate(rotation);
        ctx.scale(drawScale, drawScale);

        // Shadow
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 10 * UI_SCALE;
        ctx.shadowOffsetY = 5 * UI_SCALE;

        this.drawRoundedRect(-CARD_W/2, -CARD_H/2, CARD_W, CARD_H, CARD_RADIUS, COLORS.white);
        ctx.shadowColor = "transparent";

        if (!faceUp) {
            // Bagian Belakang
            let innerMargin = 5 * UI_SCALE;
            this.drawRoundedRect(-CARD_W/2 + innerMargin, -CARD_H/2 + innerMargin, CARD_W - innerMargin*2, CARD_H - innerMargin*2, CARD_RADIUS, COLORS.black);
            
            ctx.fillStyle = COLORS.red;
            ctx.beginPath();
            ctx.ellipse(0, 0, CARD_W/2.5, CARD_H/4, -30 * Math.PI/180, 0, Math.PI*2);
            ctx.fill();

            ctx.fillStyle = COLORS.yellow;
            ctx.font = `bold italic ${24 * UI_SCALE}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            ctx.save();
            ctx.rotate(-30 * Math.PI/180);
            ctx.shadowColor = "black"; ctx.shadowBlur = 2; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1;
            ctx.fillText("UNO", 0, 2*UI_SCALE);
            ctx.restore();

        } else {
            // Bagian Depan
            let mainColor = (this.color === 'black') ? COLORS.black : COLORS[this.color];
            let innerMargin = 5 * UI_SCALE;
            this.drawRoundedRect(-CARD_W/2 + innerMargin, -CARD_H/2 + innerMargin, CARD_W - innerMargin*2, CARD_H - innerMargin*2, CARD_RADIUS, mainColor);

            if (this.type === 'wild' || this.type === 'wild4') {
                this.drawWildFace();
            } else {
                this.drawNormalFace(mainColor);
            }

            if (dimmed) {
                ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
                ctx.beginPath(); ctx.roundRect(-CARD_W/2, -CARD_H/2, CARD_W, CARD_H, CARD_RADIUS); ctx.fill();
            }
        }
        ctx.restore();
    }

    drawNormalFace(mainColor) {
        ctx.save();
        ctx.rotate(-25 * Math.PI / 180);
        ctx.fillStyle = COLORS.white;
        
        ctx.shadowColor = "rgba(0,0,0,0.2)";
        ctx.shadowBlur = 5;
        ctx.beginPath();
        ctx.ellipse(0, 0, CARD_W/1.8, CARD_H/3.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowColor = "transparent";

        ctx.fillStyle = mainColor;
        ctx.shadowColor = "rgba(0,0,0,0.3)";
        ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1;
        
        let displayVal = this.value;
        if (displayVal === 'skip') displayVal = '⊘';
        else if (displayVal === 'reverse') displayVal = '⇄';
        
        let fontSize = (displayVal.length > 1) ? (35 * UI_SCALE) : (50 * UI_SCALE);
        ctx.font = `bold italic ${fontSize}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(displayVal, -2 * UI_SCALE, 4 * UI_SCALE);
        ctx.restore();

        ctx.fillStyle = COLORS.white;
        ctx.font = `bold ${16 * UI_SCALE}px Arial`;
        ctx.textAlign = "left";
        let offset = 8 * UI_SCALE;
        let offsetY = 18 * UI_SCALE;
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        
        ctx.fillText(displayVal, -CARD_W/2 + offset, -CARD_H/2 + offsetY);
        ctx.save();
        ctx.rotate(Math.PI);
        ctx.fillText(displayVal, -CARD_W/2 + offset, -CARD_H/2 + offsetY);
        ctx.restore();
    }

    drawWildFace() {
        ctx.save();
        let size = 30 * UI_SCALE;
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, size, Math.PI, 1.5*Math.PI); ctx.lineTo(0,0); ctx.fillStyle = COLORS.red; ctx.fill();
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, size, 1.5*Math.PI, 0); ctx.lineTo(0,0); ctx.fillStyle = COLORS.blue; ctx.fill();
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, size, 0, 0.5*Math.PI); ctx.lineTo(0,0); ctx.fillStyle = COLORS.green; ctx.fill();
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, size, 0.5*Math.PI, Math.PI); ctx.lineTo(0,0); ctx.fillStyle = COLORS.yellow; ctx.fill();
        ctx.restore();

        ctx.fillStyle = COLORS.black;
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.font = `bold italic ${28 * UI_SCALE}px Arial`;
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        
        let val = (this.value === '+4') ? '+4' : ''; 
        if(val) {
            ctx.strokeText(val, 2 * UI_SCALE, 2 * UI_SCALE);
            ctx.fillText(val, 2 * UI_SCALE, 2 * UI_SCALE);
        }

        ctx.fillStyle = COLORS.white;
        ctx.font = `bold ${14 * UI_SCALE}px Arial`;
        let cornerSym = (this.value === '+4') ? '+4' : 'W';
        ctx.textAlign = "left";
        let offset = 8 * UI_SCALE;
        let offsetY = 18 * UI_SCALE;
        ctx.fillText(cornerSym, -CARD_W/2 + offset, -CARD_H/2 + offsetY);
        ctx.save();
        ctx.rotate(Math.PI);
        ctx.fillText(cornerSym, -CARD_W/2 + offset, -CARD_H/2 + offsetY);
        ctx.restore();
    }

    drawRoundedRect(x, y, w, h, r, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.roundRect(x, y, w, h, r);
        ctx.fill();
    }
}

/**
 * ENGINE GAME
 */
class Game {
    constructor() {
        this.deck = [];
        this.discardPile = [];
        this.players = {}; 
        this.turnOrder = [];
        this.turnIndex = 0;
        this.direction = 1;
        
        this.playerCount = 2; 
        this.currentColor = ''; 
        this.message = "";
        this.particles = []; 
        this.activeAnimation = null; 
        
        this.currentLang = 'ID'; 

        this.btn2Player = {};
        this.btn4Player = {};
        this.btnOnline = {};
        this.btnQuit = {};
        this.btnLang = {}; 

        this.deckHitbox = { x: 0, y: 0, w: 0, h: 0 };
        this.comingSoonTimer = 0;
        this.activeModal = null; 
        this.tempInput = ""; 

        this.mustDraw = false;
        this.blinkAlpha = 1.0;
        this.blinkDir = -0.05;

        const randomNames = ["Lathif", "Player1", "Jagoan", "Tamu", "Budi", "Siti", "UnoPro"];
        this.playerName = randomNames[Math.floor(Math.random() * randomNames.length)];
        const avatarColors = [COLORS.red, COLORS.blue, COLORS.green, COLORS.yellow];
        this.playerAvatarColor = avatarColors[Math.floor(Math.random() * avatarColors.length)];

        this.botProfiles = {};
        this.initBackgroundParticles();
    }

    initBackgroundParticles() {
        this.bgParticles = [];
        for(let i=0; i<50; i++) {
            this.bgParticles.push({
                x: Math.random() * SCREEN_W,
                y: Math.random() * SCREEN_H,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                size: Math.random() * 3 + 1,
                alpha: Math.random() * 0.5
            });
        }
    }

    updateBackgroundParticles() {
        for(let p of this.bgParticles) {
            p.x += p.vx;
            p.y += p.vy;
            if(p.x < 0) p.x = SCREEN_W;
            if(p.x > SCREEN_W) p.x = 0;
            if(p.y < 0) p.y = SCREEN_H;
            if(p.y > SCREEN_H) p.y = 0;
        }
    }

    startGame(count) {
        this.playerCount = count;
        this.createDeck();
        this.shuffleDeck();
        
        this.players = {};
        this.players['human'] = [];
        
        this.botProfiles = {};
        const botNamesList = ["Alex", "Sarah", "Mike", "Luna", "Rizky", "Dewi", "Budi", "Asep", "Budi"];
        const botColorsList = [COLORS.red, COLORS.blue, COLORS.green, COLORS.yellow, COLORS.grey];
        
        let botIds = [];
        if (count === 2) {
            botIds = ['botTop'];
            this.turnOrder = ['human', 'botTop'];
        } else {
            botIds = ['botLeft', 'botTop', 'botRight'];
            this.turnOrder = ['human', 'botLeft', 'botTop', 'botRight'];
        }

        botIds.forEach((id, idx) => {
            this.players[id] = [];
            this.botProfiles[id] = {
                name: botNamesList[Math.floor(Math.random() * botNamesList.length)],
                color: botColorsList[idx % botColorsList.length]
            };
        });

        this.deal();
        
        let first = this.deck.pop();
        while(first.color === 'black') {
            this.deck.unshift(first);
            this.shuffleDeck();
            first = this.deck.pop();
        }
        this.discardPile = [first];
        this.currentColor = first.color;
        
        this.turnIndex = 0;
        this.direction = 1;
        this.mustDraw = false;
        currentState = STATE.PLAYING;
        this.message = LANG[this.currentLang].turn_you;
    }

    createDeck() {
        this.deck = [];
        const colors = ['red', 'blue', 'green', 'yellow'];
        const values = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+2', 'skip', 'reverse'];
        
        for (let c of colors) {
            for (let v of values) {
                this.deck.push(new Card(c, v, (v.length > 1 || isNaN(v)) ? 'action' : 'number'));
                if (v !== '0') this.deck.push(new Card(c, v, (v.length > 1 || isNaN(v)) ? 'action' : 'number'));
            }
        }
        for(let i=0; i<4; i++) {
            this.deck.push(new Card('black', 'W', 'wild'));
            this.deck.push(new Card('black', '+4', 'wild4'));
        }
    }

    shuffleDeck() {
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }

    deal() {
        for(let i=0; i<7; i++) {
            for (let pid of this.turnOrder) {
                this.players[pid].push(this.deck.pop());
            }
        }
    }

    drawCard(who, count=1) {
        for(let i=0; i<count; i++) {
            if (this.deck.length === 0) {
                if (this.discardPile.length > 1) {
                    let top = this.discardPile.pop();
                    this.deck = [...this.discardPile];
                    this.discardPile = [top];
                    this.shuffleDeck();
                    this.showMessage("Mengocok ulang...");
                } else {
                    this.showMessage("Kartu habis!"); return;
                }
            }
            this.players[who].push(this.deck.pop());
        }
    }

    getCurrentPlayer() {
        return this.turnOrder[this.turnIndex];
    }

    update() {
        this.updateBackgroundParticles();

        let btnW = 200 * UI_SCALE;
        let btnH = 55 * UI_SCALE;
        let padding = 15 * UI_SCALE;
        
        this.btn2Player.w = btnW; this.btn2Player.h = btnH;
        this.btn4Player.w = btnW; this.btn4Player.h = btnH;
        this.btnOnline.w = btnW; this.btnOnline.h = btnH;
        
        this.btnLang.w = 50 * UI_SCALE; this.btnLang.h = 35 * UI_SCALE;
        this.btnLang.x = SCREEN_W - this.btnLang.w - padding;
        this.btnLang.y = padding;

        this.btnQuit.w = 100 * UI_SCALE; this.btnQuit.h = 40 * UI_SCALE;
        this.btnQuit.x = SCREEN_W - this.btnQuit.w - padding;
        this.btnQuit.y = padding;
        
        let centerX = SCREEN_W / 2;
        let centerY = SCREEN_H / 2;
        let deckX = centerX - CARD_W - (15 * UI_SCALE); 
        let deckY = centerY;
        this.deckHitbox = { 
            x: deckX - CARD_W/2, 
            y: deckY - CARD_H/2, 
            w: CARD_W, 
            h: CARD_H 
        };

        if (this.activeModal) {
            if (mouse.clicked) {
                this.handleModalClick();
                mouse.clicked = false;
            }
            return; 
        }

        if (this.activeAnimation) {
            this.activeAnimation.update();
            if (this.activeAnimation.finished) {
                this.activeAnimation = null;
            } else {
                return;
            }
        }

        if (currentState === STATE.MENU) {
            let cx = SCREEN_W/2;
            let cy = SCREEN_H/2;
            
            this.btn2Player.x = cx - this.btn2Player.w - (10 * UI_SCALE);
            this.btn2Player.y = cy + (40 * UI_SCALE);
            this.btn4Player.x = cx + (10 * UI_SCALE);
            this.btn4Player.y = cy + (40 * UI_SCALE);
            this.btnOnline.x = cx - this.btnOnline.w / 2;
            this.btnOnline.y = cy + (120 * UI_SCALE);

            if (this.comingSoonTimer > 0) this.comingSoonTimer--;

            if (mouse.clicked) {
                if (this.isMouseOver(this.btnLang)) {
                    this.currentLang = this.currentLang === 'ID' ? 'EN' : 'ID';
                    mouse.clicked = false;
                    return;
                }

                let pSize = 50 * UI_SCALE;
                let distProfile = Math.sqrt((mouse.x - pSize)**2 + (mouse.y - pSize)**2);
                if (distProfile < (40*UI_SCALE) || (mouse.x > pSize && mouse.x < (250*UI_SCALE) && mouse.y > (20*UI_SCALE) && mouse.y < (80*UI_SCALE))) {
                    this.activeModal = 'PROFILE';
                    this.tempInput = this.playerName; 
                    mouse.clicked = false;
                    return;
                }

                if (this.isMouseOver(this.btn2Player)) {
                    this.startGame(2);
                    mouse.clicked = false;
                } else if (this.isMouseOver(this.btn4Player)) {
                    this.startGame(4);
                    mouse.clicked = false;
                } else if (this.isMouseOver(this.btnOnline)) {
                    this.comingSoonTimer = 120;
                    mouse.clicked = false;
                }
            }
            return;
        }

        if (currentState === STATE.GAME_OVER) {
            this.updateParticles();
            if(mouse.clicked) { 
                showInterstitialAd(); 
                currentState = STATE.MENU; 
                mouse.clicked = false; 
            }
            return;
        }

        if (mouse.clicked && this.isMouseOver(this.btnQuit)) {
             this.activeModal = 'QUIT';
             mouse.clicked = false;
             return;
        }

        let currPlayer = this.getCurrentPlayer();

        if (currPlayer !== 'human' && currentState === STATE.PLAYING && !this.botTimer) {
            this.botTimer = setTimeout(() => this.botPlay(currPlayer), 1500);
        }

        if (currPlayer === 'human' && currentState === STATE.PLAYING) {
            let hasMove = false;
            for(let c of this.players.human) {
                if (this.isValidMove(c)) { hasMove = true; break; }
            }
            this.mustDraw = !hasMove;
            
            if (this.mustDraw) {
                 this.blinkAlpha += this.blinkDir;
                 if (this.blinkAlpha <= 0.3 || this.blinkAlpha >= 1.0) this.blinkDir *= -1;
            } else {
                 this.blinkAlpha = 1.0;
            }

            let hand = this.players.human;
            let spacing = Math.min(50 * UI_SCALE, (SCREEN_W - (100 * UI_SCALE)) / hand.length);
            let startX = (SCREEN_W - (hand.length * spacing)) / 2 + spacing/2; 
            let y = SCREEN_H - CARD_H/2 - (20 * UI_SCALE);

            let hoveredIndex = -1;
            for (let i = hand.length - 1; i >= 0; i--) {
                let cardX = startX + i * spacing;
                if (mouse.x >= cardX - CARD_W/2 && mouse.x <= cardX + CARD_W/2 &&
                    mouse.y >= y - CARD_H/2 && mouse.y <= y + CARD_H/2 && hoveredIndex === -1) {
                    hand[i].isHovered = true;
                    hoveredIndex = i;
                } else {
                    hand[i].isHovered = false;
                }
            }

            if (mouse.clicked) {
                if (hoveredIndex !== -1) {
                    this.humanPlay(hoveredIndex);
                } else {
                    let isDeckClicked = (mouse.x >= this.deckHitbox.x && mouse.x <= this.deckHitbox.x + this.deckHitbox.w &&
                                         mouse.y >= this.deckHitbox.y && mouse.y <= this.deckHitbox.y + this.deckHitbox.h);

                    if (isDeckClicked) {
                        this.drawCard('human');
                        setTimeout(() => this.nextTurn(), 500);
                    }
                }
                mouse.clicked = false;
            }
        }

        if (currentState === STATE.COLOR_PICKER && this.getCurrentPlayer() === 'human') {
            this.handleColorPickerInput();
        }
    }

    isMouseOver(btn) {
        return mouse.x >= btn.x && mouse.x <= btn.x + btn.w && mouse.y >= btn.y && mouse.y <= btn.y + btn.h;
    }

    isValidMove(card) {
        let top = this.discardPile[this.discardPile.length-1];
        if (card.color === 'black') return true;
        if (card.color === this.currentColor) return true;
        if (card.value === top.value) return true;
        return false;
    }

    humanPlay(index) {
        let card = this.players.human[index];
        if (this.isValidMove(card)) {
            this.discardPile.push(card);
            this.players.human.splice(index, 1);
            if (card.color === 'black') {
                currentState = STATE.COLOR_PICKER;
                this.pendingCard = card;
            } else {
                this.currentColor = card.color;
                this.handleSpecialCard(card);
            }
        } else {
            
        }
    }

    botPlay(playerId) {
        this.botTimer = null;
        let hand = this.players[playerId];
        let validIndices = [];
        for(let i=0; i<hand.length; i++) {
            if (this.isValidMove(hand[i])) validIndices.push(i);
        }

        if (validIndices.length > 0) {
            let index = validIndices[Math.floor(Math.random() * validIndices.length)];
            let card = hand[index];
            
            let playedCard = card;

            hand.splice(index, 1);
            
            let startX, startY, startRot;
            let centerX = SCREEN_W/2;
            let centerY = SCREEN_H/2;
            
            if (playerId === 'botTop') {
                startX = SCREEN_W/2; startY = -100; startRot = Math.PI;
            } else if (playerId === 'botLeft') {
                startX = -100; startY = SCREEN_H/2; startRot = Math.PI/2;
            } else { 
                startX = SCREEN_W + 100; startY = SCREEN_H/2; startRot = -Math.PI/2;
            }

            let endX = centerX + (Math.random()*20-10);
            let endY = centerY + (Math.random()*20-10);
            let endRot = (Math.random() - 0.5) * 0.5;

            this.activeAnimation = new CardAnimation(playedCard, startX, startY, endX, endY, startRot, endRot, () => {
                this.discardPile.push(playedCard);
                
                if (playedCard.color === 'black') {
                    let counts = {red:0, blue:0, green:0, yellow:0};
                    hand.forEach(c => { if(c.color !== 'black') counts[c.color]++; });
                    let bestColor = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
                    this.currentColor = bestColor;
                    
                    let txt = LANG[this.currentLang].bot_pick;
                    this.showMessage(`${this.getPlayerName(playerId)} ${txt} ${bestColor.toUpperCase()}`);
                    
                    this.handleSpecialCard(playedCard);
                } else {
                    this.currentColor = playedCard.color;
                    this.handleSpecialCard(playedCard);
                }
            });
        } else {
            let txt = LANG[this.currentLang].bot_draw;
            this.showMessage(`${this.getPlayerName(playerId)} ${txt}`);
            this.drawCard(playerId);
            this.nextTurn();
        }
    }

    handleSpecialCard(card) {
        let currP = this.getCurrentPlayer();
        if (this.players[currP].length === 0) {
            currentState = STATE.GAME_OVER;
            winner = currP;
            showInterstitialAd();
            this.createParticles(); 
            return;
        }
        
        let L = LANG[this.currentLang];

        if (card.value === 'reverse') {
            if (this.playerCount === 2) {
                this.showMessage(L.reverse_skip);
                 if(this.getCurrentPlayer() !== 'human') { 
                     this.botTimer = setTimeout(() => this.botPlay(currP), 1500);
                 }
            } else {
                this.direction *= -1;
                this.showMessage(L.reverse);
                this.nextTurn();
            }
        } else if (card.value === 'skip') {
            this.showMessage(L.skip);
            this.nextTurn(true); 
        } else if (card.value === '+2') {
            let nextIdx = (this.turnIndex + this.direction + this.turnOrder.length) % this.turnOrder.length;
            let victim = this.turnOrder[nextIdx];
            this.showMessage(`${L.plus2} ${this.getPlayerName(victim)}!`);
            this.drawCard(victim, 2);
            this.nextTurn(true); 
        } else if (card.value === '+4') {
            let nextIdx = (this.turnIndex + this.direction + this.turnOrder.length) % this.turnOrder.length;
            let victim = this.turnOrder[nextIdx];
             this.showMessage(`${L.plus4} ${this.getPlayerName(victim)}!`);
             this.drawCard(victim, 4);
             this.nextTurn(true);
        } else {
            this.nextTurn();
        }
    }

    nextTurn(skipOne = false) {
        if (currentState === STATE.GAME_OVER) return;

        let steps = skipOne ? 2 : 1;
        this.turnIndex = (this.turnIndex + (steps * this.direction)) % this.turnOrder.length;
        if (this.turnIndex < 0) this.turnIndex += this.turnOrder.length;

        let nextP = this.getCurrentPlayer();
        let L = LANG[this.currentLang];
        
        if (this.currentLang === 'ID') {
             this.message = (nextP === 'human') ? L.turn_you : L.turn_bot + this.getPlayerName(nextP);
        } else {
             this.message = (nextP === 'human') ? L.turn_you : this.getPlayerName(nextP) + L.turn_bot;
        }
    }

    getPlayerName(id) {
        if (id === 'human') return this.playerName || 'You'; 
        if (this.botProfiles[id]) return this.botProfiles[id].name;
        return id;
    }

    handleColorPickerInput() {
        let size = 80 * UI_SCALE; 
        let gap = 20 * UI_SCALE;
        let totalW = (size*4) + (gap*3);
        let startX = (SCREEN_W - totalW)/2;
        let startY = SCREEN_H/2 - size/2;
        const colors = ['red', 'blue', 'green', 'yellow'];

        if (mouse.clicked) {
            for(let i=0; i<4; i++) {
                let bx = startX + i*(size+gap);
                if (mouse.x >= bx && mouse.x <= bx+size && mouse.y >= startY && mouse.y <= startY+size) {
                    this.currentColor = colors[i];
                    currentState = STATE.PLAYING;
                    this.handleSpecialCard(this.pendingCard);
                    mouse.clicked = false; return;
                }
            }
        }
    }

    handleModalClick() {
        let w = 400 * UI_SCALE; let h = 220 * UI_SCALE;
        let x = SCREEN_W/2 - w/2;
        let y = SCREEN_H/2 - h/2;

        let btnW = 120 * UI_SCALE; let btnH = 40 * UI_SCALE;
        let btnY = y + h - (60 * UI_SCALE);
        let btn1X = x + (50 * UI_SCALE); 
        let btn2X = x + w - (50 * UI_SCALE) - btnW;

        if (this.activeModal === 'QUIT') {
            if (mouse.x >= btn1X && mouse.x <= btn1X+btnW && mouse.y >= btnY && mouse.y <= btnY+btnH) {
                showInterstitialAd();
                currentState = STATE.MENU;
                this.activeModal = null;
            }
            else if (mouse.x >= btn2X && mouse.x <= btn2X+btnW && mouse.y >= btnY && mouse.y <= btnY+btnH) {
                this.activeModal = null;
            }
        } else if (this.activeModal === 'PROFILE') {
            if (mouse.x >= btn1X && mouse.x <= btn1X+btnW && mouse.y >= btnY && mouse.y <= btnY+btnH) {
                if (this.tempInput.trim().length > 0) {
                    this.playerName = this.tempInput.substr(0, 12);
                    const avatarColors = [COLORS.red, COLORS.blue, COLORS.green, COLORS.yellow];
                    this.playerAvatarColor = avatarColors[Math.floor(Math.random() * avatarColors.length)];
                }
                this.activeModal = null;
            }
            else if (mouse.x >= btn2X && mouse.x <= btn2X+btnW && mouse.y >= btnY && mouse.y <= btnY+btnH) {
                this.activeModal = null;
            }
        }
    }

    showMessage(text) { this.message = text; }

    drawBackground() {
        let grad = ctx.createRadialGradient(SCREEN_W/2, SCREEN_H/2, 0, SCREEN_W/2, SCREEN_H/2, SCREEN_W);
        grad.addColorStop(0, '#2c3e50');
        grad.addColorStop(1, '#000000');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);

        ctx.fillStyle = "rgba(255,255,255,0.05)";
        for(let p of this.bgParticles) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
        }
    }

    drawButton(btn, colorOverride) {
        let color = colorOverride || COLORS.blue;
        let isHover = this.isMouseOver(btn);
        
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 10;
        ctx.shadowOffsetY = 5;

        ctx.fillStyle = isHover ? COLORS.yellow : color;
        ctx.beginPath(); 
        ctx.roundRect(btn.x, btn.y, btn.w, btn.h, 15 * UI_SCALE); 
        ctx.fill();
        
        ctx.shadowColor = "transparent";

        ctx.fillStyle = isHover ? "black" : "white";
        ctx.font = `bold ${22 * UI_SCALE}px 'Segoe UI', sans-serif`;
        ctx.textAlign = "center"; 
        ctx.textBaseline = "middle";
        ctx.fillText(LANG[this.currentLang][btn.text] || btn.text, btn.x + btn.w/2, btn.y + btn.h/2);
    }

    draw() {
        this.drawBackground();

        if (currentState === STATE.MENU) { 
            this.drawMenu(); 
            if (this.activeModal) this.drawModal();
            return; 
        }

        ctx.beginPath(); ctx.arc(SCREEN_W/2, SCREEN_H/2, 160 * UI_SCALE, 0, Math.PI*2);
        ctx.strokeStyle = COLORS[this.currentColor] || '#333';
        ctx.lineWidth = 10 * UI_SCALE; ctx.stroke();
        
        if (this.playerCount === 4) {
           ctx.save();
           ctx.translate(SCREEN_W/2, SCREEN_H/2);
           ctx.rotate((this.direction === 1) ? 0 : Math.PI); 
           ctx.fillStyle = "rgba(255,255,255,0.1)";
           ctx.font = `${100 * UI_SCALE}px Arial`; ctx.textAlign = "center"; ctx.textBaseline="middle";
           ctx.fillText("↻", 0, 0);
           ctx.restore();
        }

        let centerX = SCREEN_W/2; let centerY = SCREEN_H/2;

        if (this.discardPile.length > 0) {
            let top = this.discardPile[this.discardPile.length - 1];
            top.x = centerX + (15 * UI_SCALE); top.y = centerY;
            top.draw(top.x, top.y, true, 1, false, 0); 
        }

        let deckX = centerX - CARD_W - (15 * UI_SCALE); let deckY = centerY;
        // Terapkan efek kedip jika mustDraw aktif
        if (this.getCurrentPlayer() === 'human' && this.mustDraw) {
            ctx.globalAlpha = this.blinkAlpha;
        }

        for(let i=0; i<Math.min(5, this.deck.length); i++) {
            let dummy = new Card('black', '', '');
            dummy.x = deckX - (i*2*UI_SCALE);
            dummy.y = deckY - (i*2*UI_SCALE);
            dummy.draw(dummy.x, dummy.y, false); 
        }
        ctx.globalAlpha = 1.0; // Reset alpha
        
        if (this.getCurrentPlayer() === 'human') {
             ctx.shadowColor = "black"; ctx.shadowBlur = 4;
             ctx.fillStyle = "white"; ctx.font = `bold ${16 * UI_SCALE}px Arial`; 
             ctx.textAlign = "center";
             ctx.fillText(LANG[this.currentLang].draw, deckX, deckY - CARD_H/2 - (15 * UI_SCALE));
             ctx.shadowColor = "transparent";
        }

        this.drawHand('human', SCREEN_W/2, SCREEN_H - CARD_H/2 - (20 * UI_SCALE), 0);
        this.drawHand('botTop', SCREEN_W/2, CARD_H/2 + (20 * UI_SCALE), Math.PI);

        if (this.playerCount === 4) {
            this.drawHand('botLeft', CARD_H/2 + (20 * UI_SCALE), SCREEN_H/2, Math.PI/2);
            this.drawHand('botRight', SCREEN_W - CARD_H/2 - (20 * UI_SCALE), SCREEN_H/2, -Math.PI/2);
        }

        if (this.activeAnimation) {
            this.activeAnimation.draw();
        }

        ctx.fillStyle = "white"; ctx.shadowColor = "black"; ctx.shadowBlur = 4;
        ctx.font = `bold ${24 * UI_SCALE}px 'Segoe UI'`; ctx.textAlign = "center";
        ctx.fillText(this.message, SCREEN_W/2, SCREEN_H/2 - (100 * UI_SCALE));
        ctx.shadowColor = "transparent";

        this.drawButton(this.btnQuit, COLORS.red);

        if (currentState === STATE.COLOR_PICKER) this.drawColorPicker();
        if (currentState === STATE.GAME_OVER) this.drawGameOver();
        
        if (this.activeModal) this.drawModal();
    }

    drawHand(playerId, centerX, centerY, rotation) {
        let hand = this.players[playerId];
        let count = hand.length;
        if (count === 0) return;

        let spacing = 30 * UI_SCALE;
        if (playerId === 'human') spacing = Math.min(50 * UI_SCALE, (SCREEN_W - (100 * UI_SCALE)) / count);
        else spacing = Math.min(20 * UI_SCALE, (200 * UI_SCALE) / count);

        let totalW = (count - 1) * spacing;
        
        if (playerId === 'human') {
            for (let i = 0; i < count; i++) {
                let offset = (i * spacing) - (totalW / 2);
                let card = hand[i];
                let dimmed = (this.getCurrentPlayer() === 'human' && !this.isValidMove(card));
                card.draw(centerX + offset, centerY, true, 1, dimmed, 0);
            }
            return;
        }

        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(rotation);

        let avatarY = CARD_H/2 + (45 * UI_SCALE); 
        let avatarSize = 20 * UI_SCALE;
        
        let profileColor = this.botProfiles[playerId] ? this.botProfiles[playerId].color : COLORS.grey;
        ctx.beginPath(); ctx.arc(0, avatarY, avatarSize, 0, Math.PI*2);
        ctx.fillStyle = profileColor; ctx.fill();
        ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();

        ctx.fillStyle = "white"; ctx.font = `bold ${16 * UI_SCALE}px Arial`; ctx.textAlign = "center"; ctx.textBaseline = "middle";
        let name = this.getPlayerName(playerId);
        ctx.fillText(name.charAt(0).toUpperCase(), 0, avatarY);

        ctx.fillStyle = (this.getCurrentPlayer() === playerId) ? "#ffff00" : "white";
        ctx.font = `bold ${16 * UI_SCALE}px Arial`; 
        ctx.fillText(`${name} (${count})`, 0, avatarY + (30 * UI_SCALE));

        for (let i = 0; i < count; i++) {
            let offset = (i * spacing) - (totalW / 2);
            this.drawBotCard(offset, 0);
        }
        ctx.restore();
    }
    
    drawBotCard(x, y) {
        ctx.shadowColor = "rgba(0,0,0,0.3)";
        ctx.shadowBlur = 5;
        ctx.fillStyle = "white";
        ctx.beginPath(); ctx.roundRect(x - CARD_W/2, y - CARD_H/2, CARD_W, CARD_H, CARD_RADIUS); ctx.fill();
        ctx.fillStyle = COLORS.black;
        ctx.beginPath(); ctx.roundRect(x - CARD_W/2 + 4*UI_SCALE, y - CARD_H/2 + 4*UI_SCALE, CARD_W - 8*UI_SCALE, CARD_H - 8*UI_SCALE, CARD_RADIUS); ctx.fill();
        ctx.fillStyle = COLORS.red;
        ctx.font = `bold italic ${24 * UI_SCALE}px Arial`; ctx.textAlign = "center"; ctx.textBaseline = "middle";
        
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(-30 * Math.PI/180);
        ctx.fillText("UNO", 0, 2*UI_SCALE);
        ctx.restore();
        
        ctx.shadowColor = "transparent";
    }

    drawMenu() {
        ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 20;
        ctx.fillStyle = "#ff5555";
        ctx.font = `bold italic ${120 * UI_SCALE}px Arial`; ctx.textAlign = "center";
        ctx.fillText("UNO", SCREEN_W/2, SCREEN_H/2 - (120 * UI_SCALE));
        ctx.strokeStyle = "white"; ctx.lineWidth = 5 * UI_SCALE;
        ctx.strokeText("UNO", SCREEN_W/2, SCREEN_H/2 - (120 * UI_SCALE));
        ctx.shadowColor = "transparent";
        
        ctx.fillStyle = "white"; ctx.font = `${20 * UI_SCALE}px 'Segoe UI'`;
        ctx.fillText("The Classic Card Game", SCREEN_W/2, SCREEN_H/2 - (80 * UI_SCALE));

        this.btn2Player.text = 'play_2';
        this.btn4Player.text = 'play_4';
        this.btnOnline.text = 'online';
        this.btnQuit.text = 'quit'; 

        this.drawButton(this.btn2Player, COLORS.blue);
        this.drawButton(this.btn4Player, COLORS.green);
        this.drawButton(this.btnOnline, COLORS.grey);

        let pSize = 40 * UI_SCALE;
        let pX = 40 * UI_SCALE; let pY = 40 * UI_SCALE;
        
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur=10;
        ctx.beginPath(); ctx.arc(pX, pY, pSize/2, 0, Math.PI*2);
        ctx.fillStyle = this.playerAvatarColor; ctx.fill(); 
        ctx.lineWidth=2; ctx.strokeStyle="white"; ctx.stroke();
        ctx.restore();
        
        ctx.fillStyle = "white"; ctx.font = `bold ${20 * UI_SCALE}px Arial`; ctx.textAlign="center"; ctx.textBaseline="middle";
        let initial = this.playerName.charAt(0).toUpperCase();
        ctx.fillText(initial, pX, pY);

        ctx.textAlign="left"; ctx.font = `bold ${20 * UI_SCALE}px 'Segoe UI'`;
        ctx.fillText(this.playerName, pX + pSize/1.5, pY - 5*UI_SCALE);
        ctx.fillStyle = "#ccc"; ctx.font = `italic ${12 * UI_SCALE}px 'Segoe UI'`;
        let hint = LANG[this.currentLang].profile_hint;
        ctx.fillText(hint, pX + pSize/1.5, pY + 15*UI_SCALE);

        let langBtnX = SCREEN_W - 60*UI_SCALE;
        let langBtnY = 30*UI_SCALE;
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath(); ctx.roundRect(langBtnX, langBtnY, 40*UI_SCALE, 30*UI_SCALE, 5); ctx.fill();
        ctx.fillStyle = "white"; ctx.font = `bold ${14*UI_SCALE}px Arial`; ctx.textAlign="center";
        ctx.fillText(this.currentLang, langBtnX + 20*UI_SCALE, langBtnY + 15*UI_SCALE);
        
        if (this.comingSoonTimer > 0) {
            ctx.fillStyle = "rgba(0,0,0,0.85)";
            ctx.beginPath(); ctx.roundRect(SCREEN_W/2 - (180 * UI_SCALE), SCREEN_H/2 + (120 * UI_SCALE), 360 * UI_SCALE, 70 * UI_SCALE, 15 * UI_SCALE); ctx.fill();
            
            ctx.fillStyle = COLORS.yellow; ctx.font = `bold ${22 * UI_SCALE}px 'Segoe UI'`; ctx.textAlign="center";
            ctx.fillText(LANG[this.currentLang].coming_soon, SCREEN_W/2, SCREEN_H/2 + (150 * UI_SCALE));
            ctx.font = `${14 * UI_SCALE}px 'Segoe UI'`; ctx.fillStyle = "white";
            ctx.fillText(LANG[this.currentLang].coming_soon_desc, SCREEN_W/2, SCREEN_H/2 + (175 * UI_SCALE));
        }

        ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
        ctx.textAlign="center"; ctx.textBaseline="alphabetic";
        ctx.font = `${12 * UI_SCALE}px Arial`;
        ctx.fillText("© 2025 UNO Game - By Lathif", SCREEN_W / 2, SCREEN_H - (15 * UI_SCALE));
    }

    drawModal() {
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.fillRect(0,0, SCREEN_W, SCREEN_H);

        let w = 400 * UI_SCALE; let h = 220 * UI_SCALE;
        let x = SCREEN_W/2 - w/2;
        let y = SCREEN_H/2 - h/2;
        let L = LANG[this.currentLang];

        ctx.shadowColor = "black"; ctx.shadowBlur = 30;
        ctx.fillStyle = "#2c3e50";
        ctx.beginPath(); ctx.roundRect(x, y, w, h, 20 * UI_SCALE); ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.1)"; ctx.lineWidth = 2; ctx.stroke();
        ctx.shadowColor = "transparent";

        ctx.fillStyle = "white"; ctx.textAlign = "center";
        
        if (this.activeModal === 'QUIT') {
            ctx.font = `bold ${26 * UI_SCALE}px 'Segoe UI'`;
            ctx.fillText(L.quit_title, SCREEN_W/2, y + (50 * UI_SCALE));
            ctx.font = `${16 * UI_SCALE}px 'Segoe UI'`;
            ctx.fillStyle = "#ddd";
            ctx.fillText(L.quit_msg, SCREEN_W/2, y + (90 * UI_SCALE));

            this.drawModalBtn(L.btn_yes, x + (50 * UI_SCALE), y + h - (70 * UI_SCALE), COLORS.red);
            this.drawModalBtn(L.btn_no, x + w - (170 * UI_SCALE), y + h - (70 * UI_SCALE), COLORS.green);
        } 
        else if (this.activeModal === 'PROFILE') {
            ctx.font = `bold ${24 * UI_SCALE}px 'Segoe UI'`;
            ctx.fillText(L.profile_title, SCREEN_W/2, y + (40 * UI_SCALE));

            ctx.fillStyle = "white";
            ctx.fillRect(x + (50 * UI_SCALE), y + (70 * UI_SCALE), w - (100 * UI_SCALE), 40 * UI_SCALE);
            ctx.fillStyle = "black"; ctx.font = `${20 * UI_SCALE}px Arial`; ctx.textAlign="left";
            ctx.fillText(this.tempInput + "|", x + (60 * UI_SCALE), y + (97 * UI_SCALE)); 

            this.drawModalBtn(L.btn_save, x + (50 * UI_SCALE), y + h - (60 * UI_SCALE), COLORS.blue);
            this.drawModalBtn(L.btn_cancel, x + w - (170 * UI_SCALE), y + h - (60 * UI_SCALE), COLORS.red);
        }
    }

    drawModalBtn(text, x, y, color) {
        let w = 120 * UI_SCALE; let h = 45 * UI_SCALE;
        let isHover = (mouse.x >= x && mouse.x <= x+w && mouse.y >= y && mouse.y <= y+h);
        
        ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 5; ctx.shadowOffsetY=3;
        ctx.fillStyle = isHover ? COLORS.yellow : color;
        ctx.beginPath(); ctx.roundRect(x, y, w, h, 10 * UI_SCALE); ctx.fill();
        ctx.shadowColor = "transparent";
        
        ctx.fillStyle = isHover ? "black" : "white";
        ctx.font = `bold ${16 * UI_SCALE}px 'Segoe UI'`; ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(text, x + w/2, y + h/2);
    }

    drawColorPicker() {
        ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0,0,SCREEN_W, SCREEN_H);
        ctx.fillStyle = "white"; ctx.font = `bold ${30 * UI_SCALE}px 'Segoe UI'`;
        ctx.textAlign = "center";
        ctx.fillText(LANG[this.currentLang].color_pick, SCREEN_W/2, SCREEN_H/2 - (100 * UI_SCALE));

        let size = 80 * UI_SCALE; let gap = 20 * UI_SCALE;
        let totalW = (size*4) + (gap*3);
        let startX = (SCREEN_W - totalW)/2;
        let startY = SCREEN_H/2 - size/2;
        const colors = ['red', 'blue', 'green', 'yellow'];

        for(let i=0; i<4; i++) {
            let bx = startX + i*(size+gap);
            ctx.fillStyle = COLORS[colors[i]];
            
            ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 15;
            if (mouse.x >= bx && mouse.x <= bx+size && mouse.y >= startY && mouse.y <= startY+size) {
                 ctx.strokeStyle = "white"; ctx.lineWidth = 5 * UI_SCALE;
                 ctx.strokeRect(bx-(5*UI_SCALE), startY-(5*UI_SCALE), size+(10*UI_SCALE), size+(10*UI_SCALE));
                 ctx.shadowBlur = 25;
            }
            ctx.beginPath(); ctx.roundRect(bx, startY, size, size, 10*UI_SCALE); ctx.fill();
            ctx.shadowColor = "transparent";
        }
    }

    drawGameOver() {
        this.updateParticles();
        this.drawBackground(); // Draw bg behind game over text
        
        ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(0,0,SCREEN_W, SCREEN_H);
        
        let L = LANG[this.currentLang];
        let msg = (winner === 'human') ? L.win_you : `${L.win_bot_prefix}${this.getPlayerName(winner).toUpperCase()}${L.win_bot_suffix}`;
        let color = (winner === 'human') ? COLORS.green : COLORS.red;

        ctx.shadowColor = color; ctx.shadowBlur = 30;
        ctx.fillStyle = color;
        ctx.font = `bold italic ${50 * UI_SCALE}px 'Segoe UI'`; ctx.textAlign = "center";
        ctx.fillText(msg, SCREEN_W/2, SCREEN_H/2);
        ctx.shadowColor = "transparent";
        
        ctx.fillStyle = "white"; ctx.font = `${20 * UI_SCALE}px 'Segoe UI'`;
        ctx.fillText("(Tap anywhere)", SCREEN_W/2, SCREEN_H/2 + (60 * UI_SCALE));
    }

    createParticles() {
        for(let i=0; i<150; i++) {
            this.particles.push({
                x: SCREEN_W/2, y: SCREEN_H/2,
                vx: (Math.random() - 0.5) * 20, vy: (Math.random() - 0.5) * 20,
                color: Object.values(COLORS)[Math.floor(Math.random()*4)],
                life: 1.0, size: Math.random()*10+5
            });
        }
    }
    updateParticles() {
        for(let p of this.particles) {
            p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.life -= 0.01;
        }
    }
    drawParticles() {
        for(let p of this.particles) {
            if(p.life > 0) {
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            }
        }
        ctx.globalAlpha = 1.0;
    }
}

const game = new Game();

// Keyboard Listener untuk Edit Profil
window.addEventListener('keydown', (e) => {
    if (game.activeModal === 'PROFILE') {
        if (e.key === 'Backspace') {
            game.tempInput = game.tempInput.slice(0, -1);
        } else if (e.key.length === 1 && game.tempInput.length < 12) {
            game.tempInput += e.key;
        } else if (e.key === 'Enter') {
            if (game.tempInput.trim().length > 0) {
                game.playerName = game.tempInput;
                const avatarColors = [COLORS.red, COLORS.blue, COLORS.green, COLORS.yellow];
                game.playerAvatarColor = avatarColors[Math.floor(Math.random() * avatarColors.length)];
            }
            game.activeModal = null;
        } else if (e.key === 'Escape') {
            game.activeModal = null;
        }
    }
});

function loop() {
    if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        SCREEN_W = canvas.width; SCREEN_H = canvas.height;
        
        // --- LOGIKA SKALA UI UNTUK HP ---
        // Jika layar kecil (<600px), skala dikecilkan.
        // Faktor 0.6 untuk HP portrait biasa, 0.8 untuk tablet/landscape.
        UI_SCALE = SCREEN_W < 600 ? 0.6 : (SCREEN_W < 1024 ? 0.8 : 1);
        
        // Update Ukuran Kartu Global
        CARD_W = BASE_CARD_W * UI_SCALE;
        CARD_H = BASE_CARD_H * UI_SCALE;
        CARD_RADIUS = BASE_CARD_RADIUS * UI_SCALE;
    }
    game.update();
    game.draw();
    mouse.clicked = false; 
    requestAnimationFrame(loop);
}

canvas.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
canvas.addEventListener('mousedown', () => { mouse.down = true; mouse.clicked = true; });
canvas.addEventListener('mouseup', () => { mouse.down = false; });
canvas.addEventListener('touchstart', (e) => {
    mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY;
    mouse.down = true; mouse.clicked = true; e.preventDefault();
}, {passive: false});

loop();

</script>
</body>
</html>
